"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeWord = exports.removeDocumentByWord = exports.find = exports.contains = exports.insert = void 0;
const node_1 = require("./node");
const levenshtein_1 = require("../levenshtein");
const utils_1 = require("../utils");
function findAllWords(nodes, node, output, term, exact, tolerance) {
    if (node.end) {
        const { word, docs: docIDs } = node;
        if (exact && word !== term) {
            return;
        }
        // always check in own property to prevent access to inherited properties
        // fix https://github.com/LyraSearch/lyra/issues/137
        if (!Object.hasOwn(output, word)) {
            if (tolerance) {
                // computing the absolute difference of letters between the term and the word
                const difference = Math.abs(term.length - word.length);
                // if the tolerance is set, check whether the edit distance is within tolerance.
                // In that case, we don't need to add the word to the output
                if (difference <= tolerance && (0, levenshtein_1.boundedLevenshtein)(term, word, tolerance).isBounded) {
                    output[word] = [];
                }
            }
            else {
                // prevent default tolerance not set
                output[word] = [];
            }
        }
        // check if _output[word] exists and then add the doc to it
        // always check in own property to prevent access to inherited properties
        // fix https://github.com/LyraSearch/lyra/issues/137
        if ((0, utils_1.getOwnProperty)(output, word) && docIDs.length) {
            const docs = new Set(output[word]);
            const docIDsLength = docIDs.length;
            for (let i = 0; i < docIDsLength; i++) {
                docs.add(docIDs[i]);
            }
            output[word] = Array.from(docs);
        }
    }
    const nodeChildrenKeys = Object.keys(node.children);
    for (let i = 0; i < nodeChildrenKeys.length; i++) {
        const childNode = node.children[nodeChildrenKeys[i]];
        findAllWords(nodes, nodes[childNode], output, term, exact, tolerance);
    }
}
function insert(nodes, node, word, docId) {
    const wordLength = word.length;
    for (let i = 0; i < wordLength; i++) {
        const char = word[i];
        if (!node.children?.[char]) {
            const newNode = (0, node_1.create)(char);
            (0, node_1.updateParent)(newNode, node);
            nodes[newNode.id] = newNode;
            node.children[char] = newNode.id;
        }
        node = nodes[node.children[char]];
        if (i === wordLength - 1) {
            node.end = true;
            node.docs.push(docId);
        }
    }
}
exports.insert = insert;
function contains(nodes, node, word) {
    const wordLength = word.length;
    for (let i = 0; i < wordLength; i++) {
        const char = word[i];
        const next = node.children?.[char];
        if (!next) {
            return false;
        }
        node = nodes[next];
    }
    return node.end;
}
exports.contains = contains;
function find(nodes, node, { term, exact, tolerance }) {
    const output = {};
    const termLength = term.length;
    for (let i = 0; i < termLength; i++) {
        const char = term[i];
        const next = node.children?.[char];
        if (next) {
            node = nodes[next];
        }
        else if (!tolerance) {
            return output;
        }
    }
    findAllWords(nodes, node, output, term, exact, tolerance);
    return output;
}
exports.find = find;
function removeDocumentByWord(nodes, node, word, docID, exact = true) {
    if (!word) {
        return false;
    }
    const { word: nodeWord, docs: docIDs } = node;
    if (exact && node.end && nodeWord === word) {
        (0, node_1.removeDocument)(node, docID);
        if (node.children?.size && (0, utils_1.includes)(docIDs, docID)) {
            node.end = false;
        }
        return true;
    }
    const nodeChildrenKeys = Object.keys(node.children);
    for (let i = 0; i < nodeChildrenKeys.length; i++) {
        const childNode = node.children[nodeChildrenKeys[i]];
        removeDocumentByWord(nodes, nodes[childNode], word, docID);
    }
    return false;
}
exports.removeDocumentByWord = removeDocumentByWord;
function removeWord(nodes, node, word) {
    if (!word) {
        return false;
    }
    if (node.end && node.word === word) {
        if (node.children?.size) {
            node.end = false;
        }
        else {
            nodes[node.parent].children = {};
        }
        return true;
    }
    const nodeChildrenKeys = Object.keys(node.children);
    for (let i = 0; i < nodeChildrenKeys.length; i++) {
        const childNode = node.children[nodeChildrenKeys[i]];
        removeWord(nodes, nodes[childNode], word);
    }
    return false;
}
exports.removeWord = removeWord;
//# sourceMappingURL=trie.js.map