"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortTokenScorePredicate = exports.includes = exports.insertSortedValue = exports.intersectTokenScores = exports.getTokenFrequency = exports.getOwnProperty = exports.uniqueId = exports.getNanosecondsTime = exports.formatNanoseconds = exports.formatBytes = exports.isServer = void 0;
const baseId = Date.now().toString().slice(5);
let lastId = 0;
const k = 1024;
const nano = BigInt(1e3);
const milli = BigInt(1e6);
const second = BigInt(1e9);
exports.isServer = typeof window === "undefined";
function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) {
        return "0 Bytes";
    }
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}
exports.formatBytes = formatBytes;
function formatNanoseconds(value) {
    if (typeof value === "number") {
        value = BigInt(value);
    }
    if (value < nano) {
        return `${value}ns`;
    }
    else if (value < milli) {
        return `${value / nano}Î¼s`;
    }
    else if (value < second) {
        return `${value / milli}ms`;
    }
    return `${value / second}s`;
}
exports.formatNanoseconds = formatNanoseconds;
function getNanosecondsTime() {
    if (typeof process !== "undefined" && process.hrtime !== undefined) {
        return process.hrtime.bigint();
    }
    if (typeof performance !== "undefined") {
        return BigInt(Math.floor(performance.now() * 1e6));
    }
    // @todo: fallback to V8 native method to get microtime
    return BigInt(0);
}
exports.getNanosecondsTime = getNanosecondsTime;
function uniqueId() {
    return `${baseId}-${lastId++}`;
}
exports.uniqueId = uniqueId;
function getOwnProperty(object, property) {
    return Object.hasOwn(object, property) ? object[property] : undefined;
}
exports.getOwnProperty = getOwnProperty;
function getTokenFrequency(token, tokens) {
    let count = 0;
    for (const t of tokens) {
        if (t === token) {
            count++;
        }
    }
    return count;
}
exports.getTokenFrequency = getTokenFrequency;
// Adapted from https://github.com/lovasoa/fast_array_intersect
// MIT Licensed (https://github.com/lovasoa/fast_array_intersect/blob/master/LICENSE)
// while on tag https://github.com/lovasoa/fast_array_intersect/tree/v1.1.0
function intersectTokenScores(arrays) {
    var _a, _b, _c;
    if (arrays.length === 0)
        return [];
    for (let i = 1; i < arrays.length; i++) {
        if (arrays[i].length < arrays[0].length) {
            const tmp = arrays[0];
            arrays[0] = arrays[i];
            arrays[i] = tmp;
        }
    }
    const set = new Map();
    for (const elem of arrays[0]) {
        set.set(elem[0], [1, elem[1]]);
    }
    const arrLength = arrays.length;
    for (let i = 1; i < arrLength; i++) {
        let found = 0;
        for (const elem of arrays[i]) {
            const [count, score] = (_b = set.get((_a = elem[0]) !== null && _a !== void 0 ? _a : "")) !== null && _b !== void 0 ? _b : [0, 0];
            if (count === i) {
                set.set((_c = elem[0]) !== null && _c !== void 0 ? _c : "", [count + 1, score + elem[1]]);
                found++;
            }
        }
        if (found === 0) {
            return [];
        }
    }
    const result = [];
    for (const [token, [count, score]] of set) {
        if (count === arrLength) {
            result.push([token, score]);
        }
    }
    return result;
}
exports.intersectTokenScores = intersectTokenScores;
function insertSortedValue(arr, el, compareFn = sortTokenScorePredicate) {
    let low = 0;
    let high = arr.length;
    let mid;
    while (low < high) {
        mid = (low + high) >>> 1;
        if (compareFn(el, arr[mid]) < 0) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    arr.splice(low, 0, el);
    return arr;
}
exports.insertSortedValue = insertSortedValue;
function includes(array, element) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === element) {
            return true;
        }
    }
    return false;
}
exports.includes = includes;
function sortTokenScorePredicate(a, b) {
    return b[1] - a[1];
}
exports.sortTokenScorePredicate = sortTokenScorePredicate;
//# sourceMappingURL=utils.js.map