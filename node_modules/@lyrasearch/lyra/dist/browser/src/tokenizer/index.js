"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tokenize = exports.normalizationCache = void 0;
const lyra_1 = require("../lyra");
const diacritics_1 = require("./diacritics");
const utils_1 = require("../utils");
const splitRegex = {
    dutch: /[^a-z0-9_'-]+/gim,
    english: /[^a-z0-9_'-]+/gim,
    french: /[^a-z0-9äâàéèëêïîöôùüûœç-]+/gim,
    italian: /[^a-z0-9_'-]+/gim,
    norwegian: /[^a-z0-9_æøåÆØÅäÄöÖüÜ]+/gim,
    portuguese: /[^a-zà-úÀ-Ú]/gim,
    russian: /[^a-zа-яА-ЯёЁ]+/gim,
    spanish: /[^a-zA-Zá-úÁ-ÚñÑüÜ]+/gim,
    swedish: /[^a-z0-9_åÅäÄöÖüÜ-]+/gim,
    german: /[^a-zA-ZäöüÄÖÜß]+/gim,
    finnish: /[^a-z0-9äöÄÖ]+/gim,
    danish: /[^a-z0-9æøåÆØÅ]+/gim,
    hungarian: /[^a-z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/gim,
    romanian: /[^a-z0-9ăâîșțĂÂÎȘȚ]+/gim,
    serbian: /[^a-z0-9čćžšđČĆŽŠĐ]+/gim,
    turkish: /[^a-z0-9çÇğĞıİöÖşŞüÜ]+/gim,
    lithuanian: /[^a-z0-9ąčęėįšųūžĄČĘĖĮŠŲŪŽ]+/gim,
    arabic: /[^a-z0-9أ-ي]+/gim,
    nepali: /[^a-z0-9अ-ह]+/gim,
    irish: /[^a-z0-9áéíóúÁÉÍÓÚ]+/gim,
    indian: /[^a-z0-9अ-ह]+/gim,
    armenian: /[^a-z0-9ա-ֆ]+/gim,
    greek: /[^a-z0-9α-ωά-ώ]+/gim,
    indonesian: /[^a-z0-9]+/gim,
};
exports.normalizationCache = new Map();
function normalizeToken(token, language, tokenizerConfig) {
    const key = `${language}:${token}`;
    if (exports.normalizationCache.has(key)) {
        return exports.normalizationCache.get(key);
    }
    // Check if stop-words removal is enabled
    if (tokenizerConfig === null || tokenizerConfig === void 0 ? void 0 : tokenizerConfig.enableStopWords) {
        // Remove stop-words
        if ((0, utils_1.includes)(tokenizerConfig === null || tokenizerConfig === void 0 ? void 0 : tokenizerConfig.customStopWords, token)) {
            const token = "";
            exports.normalizationCache.set(key, token);
            return token;
        }
    }
    // Check if stemming is enabled
    if (tokenizerConfig === null || tokenizerConfig === void 0 ? void 0 : tokenizerConfig.enableStemming) {
        // Stem token when a stemming function is available
        if (typeof (tokenizerConfig === null || tokenizerConfig === void 0 ? void 0 : tokenizerConfig.stemmingFn) === "function") {
            token = tokenizerConfig === null || tokenizerConfig === void 0 ? void 0 : tokenizerConfig.stemmingFn(token);
        }
    }
    token = (0, diacritics_1.replaceDiacritics)(token);
    exports.normalizationCache.set(key, token);
    return token;
}
function tokenize(input, language = "english", allowDuplicates = false, tokenizerConfig = (0, lyra_1.defaultTokenizerConfig)(language)) {
    /* c8 ignore next 3 */
    if (typeof input !== "string") {
        return [input];
    }
    const splitRule = splitRegex[language];
    const tokens = input
        .toLowerCase()
        .split(splitRule)
        .map(token => normalizeToken(token, language, tokenizerConfig))
        .filter(Boolean);
    const trimTokens = trim(tokens);
    if (!allowDuplicates) {
        return Array.from(new Set(trimTokens));
    }
    return trimTokens;
}
exports.tokenize = tokenize;
function trim(text) {
    while (text[text.length - 1] === "") {
        text.pop();
    }
    while (text[0] === "") {
        text.shift();
    }
    return text;
}
//# sourceMappingURL=index.js.map