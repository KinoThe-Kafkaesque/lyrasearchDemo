"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.INVALID_TOKENIZER_FUNCTION = exports.INVALID_STEMMER_FUNCTION_TYPE = exports.CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY = exports.CUSTOM_STOP_WORDS_ARRAY_MUST_BE_STRING_ARRAY = exports.NON_SUPPORTED_HOOKS = exports.INVALID_HOOKS_OBJECT = exports.GETTER_SETTER_WORKS_ON_EDGE_ONLY = exports.LANGUAGE_NOT_SUPPORTED = exports.DOC_ID_DOES_NOT_EXISTS = exports.UNSUPPORTED_NESTED_PROPERTIES = exports.CANT_DELETE_DOCUMENT = exports.CANT_DELETE_DOC_NOT_FOUND = exports.INVALID_PROPERTY = exports.INVALID_DOC_SCHEMA = exports.INVALID_SCHEMA_TYPE = void 0;
const languages_1 = require("./tokenizer/languages");
function formatJSON(input) {
    return JSON.stringify(input, null, 2);
}
function INVALID_SCHEMA_TYPE(type) {
    return `Invalid schema type. Expected string or object, but got ${type}`;
}
exports.INVALID_SCHEMA_TYPE = INVALID_SCHEMA_TYPE;
function INVALID_DOC_SCHEMA(expected, found) {
    return `Invalid document structure. \nLyra has been initialized with the following schema: \n\n${formatJSON(expected)}\n\nbut found the following doc:\n\n${formatJSON(found)}`;
}
exports.INVALID_DOC_SCHEMA = INVALID_DOC_SCHEMA;
function INVALID_PROPERTY(name, expected) {
    return `Invalid property name. Expected a wildcard string ("*") or array containing one of the following properties: ${expected.join(", ")}, but got: ${name}`;
}
exports.INVALID_PROPERTY = INVALID_PROPERTY;
function CANT_DELETE_DOC_NOT_FOUND(id) {
    return `Document with ID ${id} does not exist.`;
}
exports.CANT_DELETE_DOC_NOT_FOUND = CANT_DELETE_DOC_NOT_FOUND;
function CANT_DELETE_DOCUMENT(docID, key, token) {
    return `Unable to delete document "${docID}" from index "${key}" on word "${token}".`;
}
exports.CANT_DELETE_DOCUMENT = CANT_DELETE_DOCUMENT;
function UNSUPPORTED_NESTED_PROPERTIES() {
    return `Nested properties are not supported in this Lyra version, but will be in the future.`;
}
exports.UNSUPPORTED_NESTED_PROPERTIES = UNSUPPORTED_NESTED_PROPERTIES;
function DOC_ID_DOES_NOT_EXISTS(id) {
    return `Document with ID ${id} does not exists`;
}
exports.DOC_ID_DOES_NOT_EXISTS = DOC_ID_DOES_NOT_EXISTS;
function LANGUAGE_NOT_SUPPORTED(lang) {
    return `Language "${lang}" is not supported.\nSupported languages are:\n - ${languages_1.SUPPORTED_LANGUAGES.join("\n - ")}`;
}
exports.LANGUAGE_NOT_SUPPORTED = LANGUAGE_NOT_SUPPORTED;
function GETTER_SETTER_WORKS_ON_EDGE_ONLY(method) {
    return `${method} works on edge only. Use edge: true in Lyra constructor to enable it.`;
}
exports.GETTER_SETTER_WORKS_ON_EDGE_ONLY = GETTER_SETTER_WORKS_ON_EDGE_ONLY;
function INVALID_HOOKS_OBJECT() {
    return "Invalid hooks object";
}
exports.INVALID_HOOKS_OBJECT = INVALID_HOOKS_OBJECT;
function NON_SUPPORTED_HOOKS(invalidHooks) {
    return `The following hooks aren't supported. Hooks: ${invalidHooks}`;
}
exports.NON_SUPPORTED_HOOKS = NON_SUPPORTED_HOOKS;
function CUSTOM_STOP_WORDS_ARRAY_MUST_BE_STRING_ARRAY() {
    return `Custom stop words array must only contain strings.`;
}
exports.CUSTOM_STOP_WORDS_ARRAY_MUST_BE_STRING_ARRAY = CUSTOM_STOP_WORDS_ARRAY_MUST_BE_STRING_ARRAY;
function CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY() {
    return `Custom stop words must be a function or an array of strings.`;
}
exports.CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY = CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY;
function INVALID_STEMMER_FUNCTION_TYPE() {
    return `tokenizer.stemmingFn property must be a function.`;
}
exports.INVALID_STEMMER_FUNCTION_TYPE = INVALID_STEMMER_FUNCTION_TYPE;
function INVALID_TOKENIZER_FUNCTION() {
    return `tokenizer.tokenizerFn must be a function.`;
}
exports.INVALID_TOKENIZER_FUNCTION = INVALID_TOKENIZER_FUNCTION;
//# sourceMappingURL=errors.js.map