import { Node } from "./prefix-tree/node";
import { Nodes } from "./prefix-tree/trie";
import { Tokenizer } from "./tokenizer";
import { Language } from "./tokenizer/languages";
import type { ResolveSchema, SearchProperties } from "./types";
export declare type TokenScore = [string, number];
declare type Index = Record<string, Node>;
declare type FrequencyMap = {
    [property: string]: {
        [documentID: string]: {
            [token: string]: number;
        };
    };
};
declare type TokenOccurrency = {
    [property: string]: {
        [token: string]: number;
    };
};
export { tokenize } from "./tokenizer";
export { formatNanoseconds } from "./utils";
export declare type PropertyType = "string" | "number" | "boolean";
export declare type PropertiesSchema = {
    [key: string]: PropertyType | PropertiesSchema;
};
export interface AfterInsertHook {
    <S extends PropertiesSchema = PropertiesSchema>(this: Lyra<S>, id: string): Promise<void> | void;
}
declare type Hooks = {
    afterInsert?: AfterInsertHook | AfterInsertHook[];
};
export declare type Stemmer = (word: string) => string;
export declare type TokenizerConfig = {
    enableStemming?: boolean;
    enableStopWords?: boolean;
    customStopWords?: ((stopWords: string[]) => string[]) | string[];
    stemmingFn?: Stemmer;
    tokenizerFn?: Tokenizer;
};
export declare type TokenizerConfigExec = {
    enableStemming: boolean;
    enableStopWords: boolean;
    customStopWords: string[];
    stemmingFn?: Stemmer;
    tokenizerFn: Tokenizer;
};
export declare type Configuration<S extends PropertiesSchema> = {
    /**
     * The structure of the document to be inserted into the database.
     */
    schema: S;
    /**
     * The default language analyzer to use.
     */
    defaultLanguage?: Language;
    edge?: boolean;
    hooks?: Hooks;
    tokenizer?: TokenizerConfig;
};
export declare type Data<S extends PropertiesSchema> = {
    docs: Record<string, ResolveSchema<S> | undefined>;
    index: Index;
    nodes: Nodes;
    schema: S;
    frequencies: FrequencyMap;
    tokenOccurrencies: TokenOccurrency;
};
export interface Lyra<S extends PropertiesSchema> extends Data<S> {
    defaultLanguage: Language;
    schema: S;
    edge: boolean;
    hooks: Hooks;
    tokenizer?: TokenizerConfig;
    frequencies: FrequencyMap;
}
export declare type InsertConfig = {
    language: Language;
};
export declare type InsertBatchConfig = InsertConfig & {
    batchSize?: number;
};
export declare type SearchParams<S extends PropertiesSchema> = {
    /**
     * The word to search.
     */
    term: string;
    /**
     * The properties of the document to search in.
     */
    properties?: "*" | SearchProperties<S>[];
    /**
     * The number of matched documents to return.
     */
    limit?: number;
    /**
     * The number of matched documents to skip.
     */
    offset?: number;
    /**
     * Whether to match the term exactly.
     */
    exact?: boolean;
    /**
     * The maximum [levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance)
     * between the term and the searchable property.
     */
    tolerance?: number;
};
export declare type SearchResult<S extends PropertiesSchema> = {
    /**
     * The number of all the matched documents.
     */
    count: number;
    /**
     * An array of matched documents taking `limit` and `offset` into account.
     */
    hits: RetrievedDoc<S>[];
    /**
     * The time taken to search.
     */
    elapsed: bigint;
};
export declare type RetrievedDoc<S extends PropertiesSchema> = {
    /**
     * The id of the document.
     */
    id: string;
    /**
     * The score of the document in the search.
     */
    score: number;
    /**
     * The document
     */
    document: ResolveSchema<S>;
};
/**
 * Creates a new database.
 * @param properties Options to initialize the database with.
 * @example
 * // Create a database that stores documents containing 'author' and 'quote' fields.
 * const db = create({
 *   schema: {
 *     author: 'string',
 *     quote: 'string'
 *   },
 *   hooks: {
 *     afterInsert: [afterInsertHook],
 *   }
 * });
 */
export declare function create<S extends PropertiesSchema>(properties: Configuration<S>): Lyra<S>;
/**
 * Inserts a document into a database.
 * @param lyra The database to insert document into.
 * @param doc The document to insert.
 * @param config Optional parameter for overriding default configuration.
 * @returns An object containing id of the inserted document.
 * @example
 * const { id } = insert(db, {
 *   quote: 'You miss 100% of the shots you don\'t take',
 *   author: 'Wayne Gretzky - Michael Scott'
 * });
 */
export declare function insert<S extends PropertiesSchema>(lyra: Lyra<S>, doc: ResolveSchema<S>, config?: InsertConfig): {
    id: string;
};
/**
 * Inserts a document into a database.
 * @param lyra The database to insert document into.
 * @param doc The document to insert.
 * @param config Optional parameter for overriding default configuration.
 * @returns A Promise object containing id of the inserted document.
 * @example
 * const { id } = insert(db, {
 *   quote: 'You miss 100% of the shots you don\'t take',
 *   author: 'Wayne Gretzky - Michael Scott'
 * });
 */
export declare function insertWithHooks<S extends PropertiesSchema>(lyra: Lyra<S>, doc: ResolveSchema<S>, config?: InsertConfig): Promise<{
    id: string;
}>;
/**
 * Inserts a large array of documents into a database without blocking the event loop.
 * @param lyra The database to insert document into.
 * @param docs Array of documents to insert.
 * @param config Optional parameter for overriding default configuration.
 * @returns Promise<void>.
 * @example
 * insertBatch(db, [
 *   {
 *     quote: 'You miss 100% of the shots you don\'t take',
 *     author: 'Wayne Gretzky - Michael Scott'
 *   },
 *   {
 *     quote: 'What I cannot createm I do not understand',
 *     author: 'Richard Feynman'
 *   }
 * ]);
 */
export declare function insertBatch<S extends PropertiesSchema>(lyra: Lyra<S>, docs: ResolveSchema<S>[], config?: InsertBatchConfig): Promise<void>;
/**
 * Removes a document from a database.
 * @param lyra The database to remove the document from.
 * @param docID The id of the document to remove.
 * @example
 * const isDeleted = remove(db, 'L1tpqQxc0c2djrSN2a6TJ');
 */
export declare function remove<S extends PropertiesSchema>(lyra: Lyra<S>, docID: string): boolean;
/**
 * Searches for documents in a database.
 * @param lyra The database to search.
 * @param params The search query.
 * @param language Optional parameter to override the default language analyzer.
 * @example
 * // Search for documents that contain 'Michael' in the 'author' field.
 * const result = search(db, {
 *   term: 'Michael',
 *   properties: ['author']
 * });
 */
export declare function search<S extends PropertiesSchema>(lyra: Lyra<S>, params: SearchParams<S>, language?: Language): SearchResult<S>;
export declare function save<S extends PropertiesSchema>(lyra: Lyra<S>): Data<S>;
export declare function load<S extends PropertiesSchema>(lyra: Lyra<S>, { index, docs, nodes, schema, frequencies, tokenOccurrencies }: Data<S>): void;
export declare function defaultTokenizerConfig(language: Language, tokenizerConfig?: TokenizerConfig): TokenizerConfigExec;
